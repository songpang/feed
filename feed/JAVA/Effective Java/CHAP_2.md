# ITEM 2

## 생성자에 매개변수가 많다면 빌더를 고려하라.

### 정적 팩터리와 생성자에 선택적 매개변수가 많을 때 고려할 수 있는 방안

1. 점층적 생성자 패턴 또는 생성자 체이닝

- 매개변수가 늘어나면 코드를 작성하거나 읽기 어렵다.

* 생성자 체이닝(점층적 생성 패턴)

```java
public A(int a, int b) {
	this(a, b, 0);
}

public A(int a, int b, int c) {
	this(a, b, c, 0);
}

public A(int a, int b, int c, int d) {
	this(a, b, c, d);
}
....
// command + P : 생성자의 파라미터를 확인할 수 있다.
// 인텔리제이를 쓰지 않는다면? 메모장에 코드를 작성해야 한다면? IDE에 의존하지 말자.
// IDE에 의존하는 개발자는 고급 개발자가 될 수 없다 !
```

2. 자바빈즈 패턴

- 완전한 객체를 만들려면 메서드를 여러번 호출해야한다. ( 일관성이 무너진 상태가 될 수도 있다 )
- 클래스를 불변으로 만들 수 없다.

- 빈 생성자를 만들어놓고 setter로 객체의 값을 세팅하는 방법
  cons. 완벽한 객체를 만들기 위해서는 메서드 호출을 여러번해야한다. (Consistency가 무너진 상태가 될 
            수 있다, 어디까지 호출해야 완벽한 객체가 될 수 있는지 모호하다.)
            클래스를 불변으로 만들 수 없다.
- 객체를 불변상태로 만드는 방법으로는 freezing 기술을 사용할 수 있다
→ JAVA에는 freezing이 없다. JS에는 freeze가있다.

**Object.freeze()**  

 메서드는 객체를 동결합니다. 동결된 객체는 더 이상 변경될 수 없습니다. 즉, 동결된 객체는 새로운 속성을 추가하거나 존재하는 속성을 제거하는 것을 방지하며 존재하는 속성의 불변성, 설정 가능성(configurability), 작성 가능성이 변경되는 것을 방지하고, 존재하는 속성의 값이 변경되는 것도 방지합니다. 또한, 동결 객체는 그 프로토타입이 변경되는것도 방지합니다. freeze()는 전달된 동일한 객체를 반환합니다.  

→ 현업에서 널리 사용되는 기술은 아님.

### 권장하는 방법 : 빌더 패턴

**플루언트 API** 또는 **메서드 체이닝**을 한다.
    
**Fluent API**
말 그대로 흘러가듯 작성하는 API. 그냥 평소에 쓰고있던 방식 이름이 플루언트 API .
    
```java
 new Builder(240, 8) // 필수 값 세팅
      .a(123) // 옵셔널한 값들 세팅
      .b(234)
      .c(345)
      .build();

// 이와 같이 필수적인 값들을 세팅하고 옵셔널한 값들을 받는 빌더패턴은 @Builder로 해결할 수 없다.
// 위와 같이 사용하려면 빌더를 스스로 정의해야한다.
```
    
- 계층적으로 설계된 클래스와 함께 사용하기 좋다.
- 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.
- 모든 경우에 빌더가 적절하지 않다.
→ `@Builder`를 사용하지 않았을 경우 작성해야 하는 코드의 양이 터무니없이 길어진다.

**Annotation Processor**

- 어노테이션 자체로는 아무 기능이 없다. 컴파일 하는 시점에 읽어들여서 코드를 조작할 수 있는 기능을 자바가 제공한다.
- 어노테이션이 붙어있으면 컴파일 할 때 롬복이 코드를 조작을 한다. 쉽게 말해 `@Builder`를 사용할 경우 Builder Class를 만들어 준다.  
→ Builder는 `AllArgsConstructor`도 만들어주는데 파라미터로  
`access = AccessLevel.PRIVATE`으로 설정해준다면 외부에서 사용할 수 없다.  
→ `@Builder`의 파라미터로 builderClassName을 주면 Builder의 이름을 설정할 수 있다.  
→ 컴파일 이후 target에서 실제로 확인할 수 있다.  
