
// 앞부분 채워넣기

## 정적 팩토리 메서드 단점

1. 생성자를 private으로 제한해두기 때문에 extends를 자유롭게하기 어렵다.  
⇒ Delegation으로 이 문제를 해결할 수 있으며 이는 일종의 장점이 될 여지도 있다.  
⇒ static한 정적 팩토리를 제공하면서 생성자를 public으로 열어둘 수도 있음.  
     → e.g. List의 new 선언과 of로 생성.
2.  자바 docs를 참고할 경우(내가 작성한 코드를 자동으로 docs로 변환이 되었을 경우) 객체 생성을 어떻게 하는지에 대한 설명이 빈약해 질 수 있다.
⇒ 코드 내에 주석으로 레퍼런스를 작성해주면 어느정도 해결할 수 있다.

### 추천되는 네이밍 컨벤션

- `of`
- `getInstance, instance`
- `newInstance, create`

- Delegation(위임)
참고 : [https://skkcha.tistory.com/32](https://skkcha.tistory.com/32)

## Item 1 : 생성자 대신 정적 팩터리 메서드를 고려하라.

1. 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.  
⇒ enum : 상수 목록을 담을 수 있는 데이터 타입.  
⇒ enum을 사용함으로써 ***Type-safety***를 보장할 수 있다.  
⇒ enum은 equals보다 == 으로 비교하는 것이 NullPointerException을 피할 수 있다.  

2. 같은 객체가 자주 요청되는 상황이라면 Flyweight 패턴을 사용할 수 있다.  
⇒ Flyweight : 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴.  
⇒ 자주 변하는 속성(또는 외적인 속성, extrinsit)과 변하지 않는 속성(또는 내적인 속성, instrinsit)을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.  
⇒ FontFactory라는 Class를 하나 만들고 그안에 cache를 만들어서 자주 사용하는 객체는 cache에서 꺼내쓴다.  
3. 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에 인스턴스화 불가 동반 클래스를 둘 이유가 별로없다.  
⇒ 인스턴스화 불가  
4. 서비스 제공자 프레임워크를 만드는 근간이된다.
5. 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야한다.
6. 브릿지 패턴
7. 의존 객체 주입 프레임워크


##### JDK 8 버전에서 인터페이스에서 기본 메서드를 가질 수 있게 변경됐다.  
* interface에서 instance 메서드를 정의 → default  
* 정적인 메서드를 정의 → static  
⇒ 기존 추상클래스는 그럼..? 다중상속을 위해서만 쓰일까?  
⇒ 실제로 이런 기능들로 인해 많은 류의 불필요했던 추상클래스들이 줄어들었다. Deprecated 됐다.  
⇒ 기존 Interface의 기능이 풍부해졌다.  

##### JDK 9에서는 interface에서 private한 static 메서드를 정의할 수 있다. 
⇒ interface 내부에서만 사용하기 위한 메서드를 정의 할 때 보통 사용.  
Interface에 많은 기능이 추가되어 Helper Class, Utility Class등의 기능을 어느정도 대체. 하지만 여전히 사용되고 있으며 사라지지 않는 데에는 이유가 있다. 대표적으로 필드를 선언할 수 없음.  

```
// How to REVERSE comparator which is already defined 
Comparator<Integer> desc = (o1, o2) → o2 - o1;
fooList.sort(desc.reverserd());
// reversed를 이용하면 재정의 하지 않고 오름차순 <-> 내림차순 가능!
```


#### 브릿지 패턴
구체적인 것과 추상적인 것을 분리해두고 사이에 다리를 두는 것.
#### 왜?
구체적인 것과 추상적인 것을 분리 시킨다면 독립적인 계층구조로 발전할 수 있게 만들 수 있다.

##### 예시
1. 챔피언+스킨마다 계속해서 클래스를 만든다.
2. 10개의 챔피언의 스킨이 1개 추가된다면 10개의 클래스를 만들어야 하는 상황에 놓인다.
3. 이를 회피하기 위해서 Delegation을 이용하여 브릿지 패턴을 사용한다.  
- 브릿지 패턴은 PSA까지 연결이 된다. (백기선 유튜브 영상에서 체크하기)


# 리플렉션
거울에 반사된 이미지를 보고 어떠한 기술을 쓰는 것

* 작성한 클래스들은 JVM의 Class Loader가 클래스들을 로딩한다.
* 읽어들인 정보들은 거울에 반사된 이미지라고 생각하면 된다.
* 가장 흔히 사용되는 것은 어노테이션 정보를 읽어들이는 것

*리플렉션은 언제 쓰이나?*
1. 특정 어노테이션이 붙어있는 클래스의 필드나 메서드를 가져와 사용할 때
2. 특정 이름 패턴에 맞는 메서드 목록을 가져와 호출 할 때 (getter, setter)

### Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라.
* 점층적 생성자 패턴 : 생성자 chaining을 통해서 코드의 중복을 줄이는 패턴.  
모든 필드를 갖는 생성자를 하나 먼저 만들어놓고, this()를 이용해서 매개변수의 개수, 초기화값을 넣어주는 방식.

#### 정적 팩터리의 생성자에 선택적 필드가 많을 때 고려할 수 있는 방안
1. 점층적 생성자 패턴 또는 생성자 체이닝 매개변수가 늘어나면 코드를 작성하거나 읽기 어려움
2. 자바빈즈 패턴 빈 생성자를 만들어놓고 setter로 객체의 값을 세팅하는 방법 완벽한 객체를 만들기 위해서는 메서드 호출을 여러번해야한다.  
(Consistency가 무너진 상태가 될 수 있다, 어디까지 호출해야 완벽한 객체가 될 수 있는지 모호하다.)  
클래스를 불변으로 만들 수 없다.  
객체를 불변상태로 만드는 방법으로는 freezing 기술을 사용할 수 있다  
→ JAVA에는 freezing이 없다. JS에는 freeze가있다.  
→ 현업에서 널리 사용되는 기술은 아님.
