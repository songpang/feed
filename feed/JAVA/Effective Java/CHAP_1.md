
// 앞부분 채워넣기

## 정적 팩토리 메서드 단점

1. 생성자를 private으로 제한해두기 때문에 extends를 자유롭게하기 어렵다.  
⇒ Delegation으로 이 문제를 해결할 수 있으며 이는 일종의 장점이 될 여지도 있다.  
⇒ static한 정적 팩토리를 제공하면서 생성자를 public으로 열어둘 수도 있음.  
     → e.g. List의 new 선언과 of로 생성.
2.  자바 docs를 참고할 경우(내가 작성한 코드를 자동으로 docs로 변환이 되었을 경우) 객체 생성을 어떻게 하는지에 대한 설명이 빈약해 질 수 있다.
⇒ 코드 내에 주석으로 레퍼런스를 작성해주면 어느정도 해결할 수 있다.

### 추천되는 네이밍 컨벤션

- `of`
- `getInstance, instance`
- `newInstance, create`

- Delegation(위임)
참고 : [https://skkcha.tistory.com/32](https://skkcha.tistory.com/32)

## Item 1 : 생성자 대신 정적 팩터리 메서드를 고려하라.

1. 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.  
⇒ enum : 상수 목록을 담을 수 있는 데이터 타입.  
⇒ enum을 사용함으로써 ***Type-safety***를 보장할 수 있다.  
⇒ enum은 equals보다 == 으로 비교하는 것이 NullPointerException을 피할 수 있다.  

2. 같은 객체가 자주 요청되는 상황이라면 Flyweight 패턴을 사용할 수 있다.  
⇒ Flyweight : 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴.  
⇒ 자주 변하는 속성(또는 외적인 속성, extrinsit)과 변하지 않는 속성(또는 내적인 속성, instrinsit)을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.  
⇒ FontFactory라는 Class를 하나 만들고 그안에 cache를 만들어서 자주 사용하는 객체는 cache에서 꺼내쓴다.  
3. 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에 인스턴스화 불가 동반 클래스를 둘 이유가 별로없다.  
⇒ 인스턴스화 불가  
4. 서비스 제공자 프레임워크를 만드는 근간이된다.
5. 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야한다.
6. 브릿지 패턴
7. 의존 객체 주입 프레임워크
